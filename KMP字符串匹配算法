//运算过程:在T里面找一下有没有跟P一样的字符串
//T[] = {a,b,a,a,c,a,b,a,b,c,a,c}
//P[] = {a,b,a,b,c}
   前缀表-1,0,0,1,2
     下标 0,1,2,3,4
简单算法：相继匹配，如果没有匹配上，那么P就整体向右移一位 效率低
KMP算法： 前期准备工作:
  1、前缀表frefix table：-1,0,0,1,2
    将P分为 所有可能的前缀{a; a,b; a,b,a; a,b,a,b; a,b,a,b,c}
		  前后缀相等 = 最长公共前后缀
        注意：1、忽略最后一个本身的字符串，第一位补充-1
              2、a,b,a 最长公共前后缀：a  长度为1;    a,b,a,b 最长公共前后缀：a，b   长度为2
  2、相继匹配，匹配若失败，比如下标为3的字符不匹配，对应的前缀表为1，把整个P向右位移，使得P[3]与T[1]相对齐，并直接从P[3]与T[1]相匹配
  3、当完成一个P的匹配后，会出现一个问题，T中不止有一个P，所以应继续位移 
        
  #include<stdio.h>
  void prefix_table(char pattern[], int prefix[], int n){
    pattern[0] = 0;
    int len = 0;
    int i=1;
    while( i < n ){
      if( pattern[i] == pattern[len] ){
        
      }
    }
  }
    
